"""Functions to selectively pick up
data from CSVs generated by crawl.py"""

from base64 import b64encode
from collections import defaultdict, namedtuple


class UserPageMonthLine:
    """Holds data from a single user-page-month CSV line.
    All attribute values are strings."""

    def __init__(self):
        self.attrs = ["user_id", "page_id", "namespace",
                      "page_is_redirect", "month",
                      "month_edits"]
        for attrname in self.attrs:
            setattr(self, attrname, None)
        self.text = ""

    def from_csv(self, csv_line):
        """Fill in values from provided CSV line"""
        csv = csv_line.strip()
        self.text = csv
        if not csv.startswith("IP:"):
            if not csv[0].isnumeric():
                return
        pieces = csv.split(",")
        paired = zip(self.attrs, pieces)
        for attrname, val in paired:
            setattr(self, attrname, val)


class BandInfo:
    """Stores data for a user or article band,
    consisting of "name", "members", and 
    "edit_count". This can be used to store
    information about, for example, the activity
    of a user band defined in one year for a
    different year."""
    
    def __init__(self, name=""):
        self.name = name
        self.members = set()
        self.edit_count = 0

    def tuplify(self):
        BandData = namedtuple("BandData", 
                              ["name", "member_count", "edit_count"])
        output = BandData(self.name, len(self.members), 
                          self.edit_count)
        return output


class Picker:
    """Sifts through CSV files to pick out
    desired data."""

    def __init__(self,
                 filepaths=None,
                 namespaces=None,
                 bots=None):
        if filepaths is None:
            self.filepaths = []
        elif type(filepaths) is str:
            raise ValueError
        else:
            self.filepaths = filepaths
        self.namespaces = namespaces
        if bots is None:
            self.bots = set()
        else:
            self.bots = set(bots)
        self.reset_counts()
            
    def reset_counts(self):
        """Set all counts to default values"""
        self.inc = 0
        self.user_ids = set()
        self.ips = set()
        self.page_ids = set()
        self.redirect_ids = set()
        self.num_user_upm = 0
        self.num_ip_upm = 0
        self.num_user_edits = 0
        self.num_ip_edits = 0
        self.basic_counts = {}
        self.by_month = False
        self.months = None
        self.by_user_band = False
        self.user_edits = None
        # bands by log 10 less 1,
        # aka number of digits:
        self.bands = [1, 2, 3, 4, None]
        self.banded_users = defaultdict(int)

    def get_edit_band(self, editcount, base=10):
        """Given an edit count, return the corresponding
        edit band. Each band consists of numbers less than
        the given power of the base number (which in the
        default base-10 case corresponds to the number of 
        digits.) The maximum edit band is None, whether 
        specified or not.
        """
        if editcount < 1:
            print("Warning! Bad edit count {}"
                  .format(editcount))
        for band in self.bands:
            if band is None:
                return None
            elif editcount < base ** band:
                return band
        print("Warning! No band specified for edit count\
               {}".format(editcount))
        return None
        
    def get_monthly_edits_by_band(self,
                                  filepath=None,
                                  banded_users=None):
        """Given a {(user_id, band)} dict,
        calculate monthly users and edits 
        from provided file."""
        if banded_users is None:
            if self.banded_users is None:
                raise ValueError
            banded_users = self.banded_users
        user_ids = set(banded_users.keys())
        banded_data = defaultdict(BandInfo)
        for line in open(filepath):
            lineobj = self.process_line(line)
            if not self.line_is_ok(lineobj):
                continue
            if lineobj.user_id in user_ids:
                month = lineobj.month
                band = banded_users[lineobj.user_id]
                band_data = banded_data[(month, band)]
                edits = int(lineobj.month_edits)
                band_data.edit_count += edits
                band_data.members.add(lineobj.user_id)
        final_data = {}  # use a standard dict to return data
        for band_label, band_data in banded_data.items():
            band_data.name = band_label
            final_data[band_label] = band_data.tuplify()[1:]
        return final_data

    def get_user_edits(self,
                       filepaths=None):
        """Given a list of filepaths, return a
        {(userid, editcount)} dict."""
        self.user_edits = defaultdict(int)
        if filepaths is None:
            filepaths = self.filepaths
        for path in filepaths:
            print("Processing {}".format(path))
            handle = open(path, encoding="utf-8")
            result = self.process_file(handle)
            self.basic_counts[path] = result
        return self.user_edits

    def get_pages_for_month(self, filepath, month):
        """Given a single filepath, return a set of
        all page IDs edited in a given month"""
        page_ids = set()
        for line in open(filepath):
            lineobj = self.process_line(line)
            if not self.line_is_ok(lineobj):
                continue
            if lineobj.month == month:
                page_ids.add(lineobj.page_id)
        return page_ids

    def get_basic_counts(self,
                         filepaths=None,
                         maxlines=None,
                         by_month=False):
        """Given filepaths to user-page-month CSV
        files, return a {filepath, <stats>} dict.
        If namespaces provided, collect only for those
        namespaces. If bots provided, exclude bots.
        Bots must be set of bot IDs (not usernames)."""
        self.basic_counts = {}
        self.by_month = by_month
        if self.by_month:
            self.months = defaultdict(Picker)
        if filepaths is None:
            filepaths = self.filepaths
        for path in filepaths:
            print("Processing {}".format(path))
            handle = open(path, encoding="utf-8")
            result = self.process_file(handle,
                                       maxlines=maxlines)
            if self.by_month:  # avoid dict of dicts
                result = [(x[0], x[1].get_results()) for x in
                          self.months.items()]
            self.basic_counts[path] = result
        return self.basic_counts

    def process_file(self, open_file, maxlines=None):
        """Process provided open_file up to maxlines,
        and return resulting stats as namedtuple."""
        self.inc = -1
        for line in open_file:
            self.inc += 1
            if not line:
                continue
            if maxlines is not None:
                if self.inc > maxlines:
                    break
            lineobj = self.process_line(line)
            self.process_lineobj(lineobj)
        if self.by_month:
            result = {}
            for month, picker in self.months.items():
                picker.bots = self.bots
                monthly_result = picker.get_results()
                result[month] = monthly_result
        else:
            result = self.get_results()
        return result

    def get_results(self):
        Results = namedtuple("Results",
                             ["num_users", "num_ips",
                              "num_pages", "num_redirects",
                              "num_user_upm", "num_ip_upm",
                              "num_user_edits", "num_ip_edits"])
        result = Results(num_users=len(self.user_ids),
                         num_ips=len(self.ips),
                         num_pages=len(self.page_ids),
                         num_redirects=len(self.redirect_ids),
                         num_user_upm=self.num_user_upm,
                         num_ip_upm=self.num_ip_upm,
                         num_user_edits=self.num_user_edits,
                         num_ip_edits=self.num_ip_edits)
        return result

    def process_ip(self, lineobj):
        """Increment counts for IP and add IP to
        self.ips"""
        self.num_ip_upm += 1
        self.num_ip_edits += int(lineobj.month_edits)
        self.ips.add(lineobj.user_id)

    def process_user(self, lineobj):
        """Increment counts for user and add user to
        self.user_ids. If user_edits is set, update."""
        self.num_user_upm += 1
        editcount = int(lineobj.month_edits)
        self.num_user_edits += editcount
        user = lineobj.user_id
        self.user_ids.add(user)
        if self.user_edits is not None:
            self.user_edits[user] += editcount

    def line_is_ok(self, lineobj):
        """Return True if line is OK to process,
        otherwise False."""
        if self.namespaces:
            if lineobj.namespace not in self.namespaces:
                return False
        if lineobj.user_id in self.bots:
            return False
        if lineobj.namespace is None:
            return False
        if lineobj.month_edits is None:
            print("Bad line at {}! {}".format(self.inc, lineobj))
            return False
        return True

    def process_line(self, line):
        """Process line into object and send for
        further processing."""
        lineobj = UserPageMonthLine()
        lineobj.from_csv(line)
        return lineobj

    def process_lineobj(self, lineobj):
        """Increment relevant stats for line"""
        if self.by_month:
            picker = self.months[lineobj.month]
            picker.process_lineobj(lineobj)
        if not self.line_is_ok(lineobj):
            return
        if lineobj.user_id.startswith("IP:"):
            self.process_ip(lineobj)
        else:  # non-bot registered user
            self.process_user(lineobj)
        page = lineobj.page_id
        if lineobj.page_is_redirect == "0":
            self.page_ids.add(page)
        elif lineobj.page_is_redirect == "1":
            self.redirect_ids.add(page)
        else:
            m = "Bad value for is_redirect:" + lineobj.text
            print(m)


def get_bot_ids(botpath, userpath):
    """Given a file with bot usernames each on one
    line, and another file with mappings between
    user_IDs and usernames, return set of bots."""
    botfile = open(botpath, "rb")
    bot_names = set()
    for line in botfile:
        line = line.rstrip()
        if not line:
            continue
        line = line.replace(b"_", b" ")
        encoded_name = b64encode(line)
        bot_names.add(encoded_name)
    bot_ids = set()
    user_file = open(userpath, "rb")
    for line in user_file:
        if line.startswith(b"IP:"):
            continue
        line = line.rstrip()
        user_id, user_name = line.split(b",")
        if user_name in bot_names:
            decoded_id = user_id.decode("utf-8")
            bot_ids.add(decoded_id)
            bot_names.remove(user_name)
    return bot_ids


def fields2line(fields):
    """Create CSV line from 'fields', ending
    with newline."""
    fields = [x.strip().replace(",", "\\,")
              for x in fields]
    line = ",".join(fields)
    line += "\n"
    return line


def stats2csv(stats, unit_name="year"):
    """Given a {(unit, <data>)} dict, where
    data is a namedtuple and unit is a year or month,
    convert to CSV"""
    csv = ""
    headers = [unit_name]
    data = list(stats.values())[0]
    headers.extend(list(data._fields))
    first_line = fields2line(headers)
    csv += first_line
    for year, data in stats.items():
        values = [year] + list(data)
        values = [str(x) for x in values]
        line = fields2line(values)
        csv += line
    return csv


class BasicStats:
    """Holder for basic stats from
    digesting user-page-months CSV"""

    def __init__(self):
        self.peak_user_page_months = {}
        self.current_peaks = defaultdict(int)
        self.total_revisions = 0
        self.page_ids = set()
        self.user_ids = set()
        self.collect_pages = False
        self.mainspace_only = False
        self.mainspace_user_months = set()
        self.mainspace_page_months = set()
        self.months_by_namespace = defaultdict(int)
        self.edits_by_namespace = defaultdict(int)

    def process_line(self, lineobj):
        """Given a UserPageMonthLine object,
        process it for global stats."""
        if lineobj.user_id is None:
            print("Skipping line object with no user ID")
            return
        self.months_by_namespace[lineobj.namespace] += 1
        count = int(lineobj.month_edits)
        self.total_revisions += count
        if self.collect_pages is True:
            if lineobj.namespace == "0" or \
               self.mainspace_only is False:
                self.page_ids.add(lineobj.page_id)
                self.user_ids.add(lineobj.user_id)
        user_month = (lineobj.user_id, lineobj.month)
        page_month = (lineobj.page_id, lineobj.month)
        self.edits_by_namespace[lineobj.namespace] += count
        if count > self.current_peaks[lineobj.namespace]:
            self.peak_user_page_months[lineobj.namespace] = \
                (lineobj.user_id, lineobj.page_id, count)
            self.current_peaks[lineobj.namespace] = count
        if lineobj.namespace == "0":
            if self.collect_pages:
                self.mainspace_user_months.add(user_month)
                self.mainspace_page_months.add(page_month)

    def load_stats(self,
                   months_filepath="user_page_months_output.csv",
                   limit=None):
        """Load dict of users from CSV files in format:
        {(user_id, User)}."""
        with open(months_filepath, encoding="utf-8") as upm_file:
            linecount = 0
            for line in upm_file:
                linecount += 1
                if limit is not None:
                    if linecount > limit:
                        print("Ending at line {}".format(linecount))
                        break
                lineobj = UserPageMonthLine()
                lineobj.from_csv(line)
                if linecount == 1 and lineobj.user_id is None:
                    # skip header
                    continue
                self.process_line(lineobj)


def load_all_upms(filepath):
    """Given a filepath to a user-page-month CSV,
    return a set of all user-page-months and complain
    if any dups are found."""
    all_upms = set()
    with open(filepath) as lines:
        for line in lines:
            lineobj = UserPageMonthLine()
            lineobj.from_csv(line)
            if lineobj.user_id is None:
                continue
            upm = (lineobj.user_id, lineobj.page_id, lineobj.month)
            if upm in all_upms:
                print("Found duplicate:", str(upm))
            all_upms.add(upm)
    return all_upms


def get_year_band_totals(directory, bots=None):
    """Get yearly totals of edits and users,
    by user edit band for that year."""
    from re import search
    if bots is None:
        print("Warning! Proceeding without bot file.")
        bots = set()
    files = [x for x in os.listdir(directory) if "user_page" in x]
    paths = [os.path.join(directory,x) for x in files]
    output = list()
    for p in paths:
        print(p)
        picker = pick.Picker([p],["0"],bots)
        user_edits = picker.get_user_edits()
        starter = [(1,0),(2,0),(3,0),(4,0),(None,0)]
        band_edits = dict(starter)
        band_users = dict(starter)
        for user, edits in user_edits.items():
            user_band = picker.get_edit_band(edits)
            band_edits[user_band] += edits
            band_users[user_band] += 1
        year_finder = re.search("\d{4}", p)
        if year_finder:
            label = year_finder.group(1)
        data = (p[4:8], list(band_edits.items()), list(band_users.items()))
        output.append(data)
    return output
